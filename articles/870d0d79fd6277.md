---
title: "TypeScriptにて型レベルで型ガードを実現する"
emoji: "🛡"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["TypeScript"]
published: false
---

この記事は過去に書いた以下の記事の移植になります。
-  [tsでobjectの共用体型(union type)から特定の型を取り出すutil typeを実装する - Qiita](https://qiita.com/katsuya_U/items/6269b50f27b54bb84fff)


## 概要

```typescript

type SuccessResult = {
  status: "success"
}

type ErrorResult = {
  status: "error"
  errorCode: number
  errorMessage: string
}

type AbortResult = {
  status: "abort"
}

export type Result = SuccessResult | ErrorResult | AbortResult
```
↑このような型が定義してあったとして

```typescript
declare const result: Result

result.errorCode // error! プロパティ 'errorCode' は型 'Result' に存在しません。

if (result.status === "error") {
  // result is ErrorResult
  result.errorCode // ok!
}

```

[型ガード](https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types)によって、`result.status === "error"`の時`result`は`ErrorResult`型として扱うことができます。

しかし、デフォルトのtsの型機能だけで`Result`型のような共用体型から特定の型を取り出すことができません。

そこで、

```typescript
type ErrorResult2 = FindFromUnion<Result, "status", "error">
// ErrorResult2 is ErrorResult
```

上記のような、3つの型

- objectの共用体型
- keyとなるプロパティ名(string literal型)
- 特定ののkeyと一致する名称(string literal型)

を指定して、共用体型から特定の型を取り出す`FindFromUnion`型を実装します。

## 実装

ts 4.3.5で確認しています。

```typescript
type FindFromUnion<
  Target extends {},
  KeyProp extends keyof Target,
  Key extends Target[KeyProp]
> = Target extends { [x in KeyProp]: Key } ? Target : never;
```

<details><summary>tsの組み込み型を使う場合</summary>


```typescript
type FindFromUnion<
  Target extends {},
  KeyProp extends keyof Target,
  Key extends Target[KeyProp]
> = Extract<Target, Record<KeyProp, Key>>
```

こちらの方が見やすいかもしれませんね。

</details>


## なぜこれが必要なのか

はっきり言って`ErrorResult2`型のような使い方はあまりしないと思います。
なぜならそもそも元の`ErrorResult`型をexportすれば良いからです。

では、なぜ`FindFromUnion`型が必要になったのか？

それは、[Mapped types](https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types)を使って型を動的に作るときに絶大なパワーを発揮するからです。

```typescript
// Result["status"] is "success" | "error" | "abort"
type ResultMap = {
  [ResultStatus in Result["status"]]: ResultStatus
}
/*
ResultMap is {
  success: "success";
  error: "error";
  abort: "abort";
}
*/
```

最初に出てきた`Result`型を使って、上記のような`ResultMap`型が作れます。
重要なのは、`ResultStatus`型がそれぞれ、`"success"`型、`"error"`型、`"abort"`型になることです。

これに`FindFromUnion`型を使うと、

```typescript
type ResultMap = {
  [ResultStatus in Result["status"]]: FindFromUnion<Result, "status", ResultStatus>
}
/*
ResultMap is {
  success: SuccessResult;
  error: ErrorResult;
  abort: AbortResult;
}
*/
```

このように、共用体型のオブジェクトから、動的にobjectを作るなんてことができるんです！！！

もちろん、オプショナルや、関数にすることもできます

```typescript
type ResultFuncMap = {
  [ResultStatus in Result["status"]]?: (result: FindFromUnion<Result, "status", ResultStatus>) => void
}
/*
ResultMap is {
  success: SuccessResult;
  error: ErrorResult;
  abort: AbortResult;
}
*/
```

さらにさらに、ResultFuncMapを使ってこんなこともできます

```typescript

const setResultHandler = (handlerMap: ResultFuncMap) => {
  // 何かしらの処理
}

setResultHandler({
  success() {
    // 成功時の処理
  },
  //     ↓ ErrorResultをそのまま引数に分割している
  error({ errorCode, errorMessage }) {
    // エラー時の処理
  },
})
```

## まとめ


objectの共用体型から特定の型を取り出す`FindFromUnion`型を実装してみました。

`FindFromUnion`型を使う機会はあまりなさそうですが、Mapped typesと合わせて使うととても強力なので、是非使ってみてください！

(ところで、ts 4.1の[Template Literal Types](https://devblogs.microsoft.com/typescript/announcing-typescript-4-1-beta/#template-literal-types)、楽しみだなぁー)
