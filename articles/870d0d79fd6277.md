---
title: "TypeScriptにて型レベルで型ガードを実現する"
emoji: "🛡"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["TypeScript"]
published: false
---
:::message

この記事は過去に書いた記事に一部修正した移植になります。
-  [tsでobjectの共用体型(union type)から特定の型を取り出すutil typeを実装する - Qiita](https://qiita.com/katsuya_U/items/6269b50f27b54bb84fff)

:::


## 概要

```typescript

type SuccessResult = {
  status: "success"
}

type ErrorResult = {
  status: "error"
  errorCode: number
  errorMessage: string
}

type AbortResult = {
  status: "abort"
}

export type Result = SuccessResult | ErrorResult | AbortResult
```
↑このような型が定義してあったとして

```typescript
declare const result: Result

result.errorCode // error! プロパティ 'errorCode' は型 'Result' に存在しません。

if (result.status === "error") {
  // result is ErrorResult
  result.errorCode // ok!
}

```

[型ガード](https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types)によって、`result.status === "error"`の時`result`は`ErrorResult`型として扱うことができます。

しかし、デフォルトのtsの型機能だけで`Result`型のような共用体型から特定の型を取り出すことができません。

そこで、

```typescript
type ErrorResult2 = FindFromUnion<Result, "status", "error">
// ErrorResult2 is ErrorResult
```

上記のような、3つの型

- objectの共用体型
- keyとなるプロパティ名(string literal型)
- 特定ののkeyと一致する名称(string literal型)

を指定して、共用体型から特定の型を取り出す`FindFromUnion`型を実装します。

## 実装

ts 4.3.5で確認しています。([全体のソースのプレイグランド](https://www.typescriptlang.org/ja/play?ssl=42&ssc=2&pln=38&pc=1#code/C4TwDgpgBAYglgOwCYwE4HsC2BVBd0IA8AUFFACoCGqA5hMFBAB7ATIDOUA3gL4A0pKAGkIIAAoYwjFmyScA1qPQAzCtTrABZESGmsOa2vQDaOiejABdYgD4oAXkMa9szlyjGmURMNHmrAFy+ujxQAPxO9FBBCBAAbhCogsSgkFAAygCuAMbZEOzsAEr5mQA2DI5cguzAlMCZ7EEAROw5eQVNxDzEKeDQAKKoGKjFreUO3NW19Y1QTYnDnWQL6KgAwuhIEDGZmABGiYIrqACy+eyUdEE1qIg0XT2p0ACCe6vAo2UVk2Q1dQ3NShvVDATrdXppT7jRxZXLnKEMAA+UEGwwRUGRr3eCMefSgCJOlCklUExgR6WmDW8CHxJXKxhalPYTUsliC8GQaCwuHwRARfDmfxmTQF5KZNgeAHoAFTEAlEiZVX5tc5BWHtIp04AAbiOQ1WQVRqwRurIQPeQSxIJND2lktxkK1MEyCGyhOJPw8Yv+nB8CIZQoaLMsYSCAApUFr2YgUBgcHgCIR+YKmSLaWNgBSfTYAJQOOxxdBwJBS2UI52u92K6oqgqhqBhiNRjK1zUZvP2AtFpB55EurbKRAQJCmxj61D1xuRjOG8cIjtd4u9qD9iCD2IjwTmkGTpszqBWj5ahdQQtLjEr5Broeb7p2nrZAg1KDsegIgASlGQpUSEzDAAsvyQH9TiJIJyxdN0iRPJUoElSUoAAOmQh5iFfI8M0-b9EjDWDWjhAowzzWCyHgqBskoV8X1bQR+D1YZcLHYYNi2AVjjOApLmgHhiMEUiEIoqjjlogQeKAA))

```typescript
type FindFromUnion<
  Target extends {},
  KeyProp extends keyof Target,
  Key extends Target[KeyProp]
> = Target extends { [x in KeyProp]: Key } ? Target : never;
```

:::details tsの組み込み型を使う場合

```typescript
type FindFromUnion<
  Target extends {},
  KeyProp extends keyof Target,
  Key extends Target[KeyProp]
> = Extract<Target, Record<KeyProp, Key>>
```

こちらの方が見やすいかもしれませんね。

:::



## なぜこれが必要なのか

はっきり言って`ErrorResult2`型のような使い方はあまりしないと思います。
なぜならそもそも元の`ErrorResult`型をexportすれば良いからです。

では、なぜ`FindFromUnion`型が必要になったのか？

それは、[Mapped types](https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types)を使って型を動的に作るときに絶大なパワーを発揮するからです。

```typescript
// Result["status"] = "success" | "error" | "abort"
type ResultMap = {
  [ResultStatus in Result["status"]]: ResultStatus
}
/*
ResultMap is {
  success: "success";
  error: "error";
  abort: "abort";
}
*/
```

最初に出てきた`Result`型を使って、上記のような`ResultMap`型が作れます。
重要なのは、`ResultStatus`型がそれぞれ、`"success"`型、`"error"`型、`"abort"`型になることです。

これに`FindFromUnion`型を使うと、

```typescript
type ResultMap = {
  [ResultStatus in Result["status"]]: FindFromUnion<Result, "status", ResultStatus>
}
/*
ResultMap is {
  success: SuccessResult;
  error: ErrorResult;
  abort: AbortResult;
}
*/
```

このように、共用体型のオブジェクトから、動的にobjectを作るなんてことができるんです！！！

もちろん、オプショナルや、関数にすることもできます

```typescript
type ResultFuncMap = {
  [ResultStatus in Result["status"]]?: (result: FindFromUnion<Result, "status", ResultStatus>) => void
}
/*
ResultFuncMap = {
  success?: ((result: SuccessResult) => void) | undefined;
  error?: ((result: ErrorResult) => void) | undefined;
  abort?: ((result: AbortResult) => void) | undefined;
}
*/
```

さらにさらに、ResultFuncMapを使ってこんなこともできます

```typescript

const setResultHandler = (handlerMap: ResultFuncMap) => {
  // 何かしらの処理
}

setResultHandler({
  success() {
    // 成功時の処理
  },
  //     ↓ ErrorResultをそのまま引数に分割している
  error({ errorCode, errorMessage }) {
    // エラー時の処理
  },
})
```

## まとめ


objectの共用体型から特定の型を取り出す`FindFromUnion`型を実装してみました。

`FindFromUnion`型を使う機会はあまりなさそうですが、Mapped typesと合わせて使うととても強力なので、是非使ってみてください！
